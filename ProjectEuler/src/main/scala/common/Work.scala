package common

import scala.annotation.tailrec

object Work {

  /**
   * Problem 1. If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
   * 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples
   * of 3 or 5 below 1000.
   */
  def problem1: Int = {
    val x = Stream.range(1, 1000).filter {
      x => (x % 3 == 0) || (x % 5 == 0)
    }
    x.foldLeft(0)(_ + _)
  }

  /**
   * Problem 2. Each new term in the Fibonacci sequence is generated by adding the previous two terms.
   * By starting with 1 and 2, the first 10 terms will be:
   * 1, 2, 3, 5, 8, 13,  21, 34, 55, 89
   * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
   * find the sum of the even-valued terms.
   */
  def fib(count: Long) = {
    @tailrec
    def go(num1: Long, num2: Long, count: Long, stream: Stream[Long]): Stream[Long] = count match {
      case 1 => stream
      case n => go(num1 + num2, num1, n - 1, stream :+ (num1 + num2))
    }
    go(1, 1, count, Stream[Long](1))
  }

  def fibCountBefore4Mil: Long = {
    @tailrec
    def go(x: Long): Long = {
      if(fib(x).exists{ x => x > 4000000} ) x - 1
      else go(x + 1)
    }
    go(1)
  }

  def problem2: Long = {
    val fibs = fib(fibCountBefore4Mil)
    //val y = fibs.map{x => if(x > 4000000) 0 else x}.map{x => if(x % 2 == 0) x else 0}
    fibs.filter{x => x % 2 == 0}.foldLeft(0L)(_ + _)
  }

  val primes = scala.collection.mutable.HashSet[Long]()

  /**
   * Problem 3. The prime factors of 13195 are 5, 7, 13 and 29. What is the
   * largest prime factor of the number 600851475143?
   */
  def isPrime(x: Long): Boolean = {
    println("is prime?: " + x)
    if(x < 2) false
    val halfPlus1 = (x / 2L) + 1L // a number can't be divisible by half of its value + 1
                                  // example: 14 can never be divisible by 8.
    if(primes.contains(x)) true
    @tailrec
    def go(p: Long): Boolean = p match {
      case a if a == halfPlus1 => primes.add(p); true    // only divisible by 1 (and itself)
      case a if x % a == 0 => false
      case _ => go(p + 1)
    }
    go(2)
  }

  def largestPrime(x: Long): Option[Long] = {
    @tailrec
    def go(p: Long): Option[Long] = p match {
      case a if a < 2 => None
      case a if (x % a == 0 && isPrime(a)) => Some(a)
      case _ => go(p - 1)
    }
    go(x - 1)
  }

  /**
   * Problem 4. A palindromic number reads the same both ways. The largest palindrome made
   *   from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   * Find the largest palindrome made from the product of two 3-digit numbers.
   */
  def getLargestPalindromeForXDigits(x: Int): Long = {
    val ps = getXDigitProducts(x)
    assert(ps.contains(9009))
    val pals = ps.filter{a => isPalindrome(a.toString)}

    pals.foldLeft(0L) {
      (acc, elem) => if(elem > acc) elem
                     else acc
    }
  }

  // TODO: see Sobral's answer on SO
  //http://stackoverflow.com/questions/22593362/outofmemory-exception-when-creating-stream-of-3-digit-products
  def getXDigitProducts(x: Int): Stream[Long] = {
    val MAX = Math.pow(10, x)
    @tailrec
    def go(outer: Int, inner: Int, acc: Stream[Long]): Stream[Long] = (outer, inner) match {
      case (MAX, _) => acc
      case (_, MAX) => println("outer:" + outer); go(outer + 1, 1, acc)
      case (_, _)   => go(outer, inner + 1, Stream[Long](outer * inner) ++ acc)
    }
    go(1, 1, Stream[Long]())
  }

  def isPalindrome(x: String) = x == x.reverse

  def getXDigitProductsTry(x: Int): Stream[Long] = {
    val MAX = Math.pow(10, x)

    def go(outer: Int, inner: Int, product: Stream[Long]): Stream[Long] = {
      if(outer == MAX) product
      else if(inner == MAX) go(outer + 1, 1, product)
      else (outer * inner) #:: go(outer, inner + 1, product)
    }
    go(1, 1, Stream[Long]())
  }

  /**
   * Problem 5.
   * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
   * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
   */

  def smallestNumDivByXNumbers(count: Int, start: Int): Option[Int] = {
    @tailrec
    def go(x: Int): Option[Int] = x match {
      case _ if isDivByX(x, count) => Some(x)
      case Long.MaxValue => None
      case _ => go(x+1)
    }
    go(start)
  }

  def isDivByX(num: Int, count: Int): Boolean = {
    @annotation.tailrec
    def go(x: Int, n: Int): Boolean = n match {
      case 1 => true
      case _ if x % n == 0 => go(x, n - 1)
      case _ => false
    }
    go(num, count)
  }

  /**
   * Problem 6. The sum of the squares of the first ten natural numbers is:
   *    1^2 + 2^2 + ... + 10^2 = 385
   * The sum of the square of the first ten natural numbers is:
   *    (1 + 2 + ... + 10)^2 = 55^2 = 3025
   * Hence the difference is 2640.
   *
   * Find the above for the first 100 numbers.
   */

  def sumOfSquares(end: Int): Double =
    List.range(0,end+1).map{x => Math.pow(x, 2)}.foldLeft(0.0)(_+_)

  def sumSquared(end: Int): Double =
    Math.pow(List.range(0, end+1).foldLeft(0.0)(_+_), 2)

  def squaresDiff(end: Int) =
    sumSquared(end) - sumOfSquares(end)

  /**
   * Problem 7. By listing the first six prime numbers, we can see that
   * the 6th prime is 13.
   *
   * What is the 10,001st prime number?
   */

    def findNthPrime(n: Int): Long = {
    @tailrec
      def go(x: Long, y: Int): Long = isPrime(x) match {
        case false => println("false, not prime"); go(x+1, y)          // not prime, recurse
        case true if y == (n - 1) => println(s"Found $n prime: $x"); x    // if we've already found y-1 primes, then we've now found the y'th prime
        case true => println(s"$x prime but y = $y"); go(x+1, y+1)            // found a prime but n hasn't been reached
      }
    go(2, 0)
  }

}