package common

import scala.annotation.tailrec

object Work {

  /**
   * Problem 1. If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
   * 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples
   * of 3 or 5 below 1000.
   */
  def problem1: Int = {
    val x = Stream.range(1, 1000).filter {
      x => (x % 3 == 0) || (x % 5 == 0)
    }
    x.foldLeft(0)(_ + _)
  }

  /**
   * Problem 2. Each new term in the Fibonacci sequence is generated by adding the previous two terms.
   * By starting with 1 and 2, the first 10 terms will be:
   * 1, 2, 3, 5, 8, 13,  21, 34, 55, 89
   * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
   * find the sum of the even-valued terms.
   */
  def fib(count: Long) = {
    @tailrec
    def go(num1: Long, num2: Long, count: Long, stream: Stream[Long]): Stream[Long] = count match {
      case 1 => stream
      case n => go(num1 + num2, num1, n - 1, stream :+ (num1 + num2))
    }
    go(1, 1, count, Stream[Long](1))
  }

  def fibCountBefore4Mil: Long = {
    @tailrec
    def go(x: Long): Long = {
      if(fib(x).exists{ x => x > 4000000} ) x - 1
      else go(x + 1)
    }
    go(1)
  }

  def problem2: Long = {
    val fibs = fib(fibCountBefore4Mil)
    //val y = fibs.map{x => if(x > 4000000) 0 else x}.map{x => if(x % 2 == 0) x else 0}
    fibs.filter{x => x % 2 == 0}.foldLeft(0L)(_ + _)
  }

  import scala.collection.immutable.HashSet

  val primes = scala.collection.mutable.HashSet[Long]()

  /**
   * Problem 3. The prime factors of 13195 are 5, 7, 13 and 29. What is the
   * largest prime factor of the number 600851475143?
   */
  def isPrime(x: Long): Boolean = {
    println("is prime?: " + x)
    if(x < 2) false
    if(primes.contains(x)) true
    val halfPlus1 = (x / 2L) + 1L // a number can't be divisible by half of its value + 1
                                  // example: 14 can never be divisible by 8.
    @tailrec
    def go(p: Long): Boolean = {
      if(p == halfPlus1) { primes.add(p); true }
      else if(x % p == 0) false
      else go(p+1)
    }
    go(2)
  }

  def largestPrime(x: Long): Option[Long] = {
    @tailrec
    def go(p: Long): Option[Long] = p match {
      case a if a < 2 => None
      case a if (x % a == 0 && isPrime(a)) => Some(a)
      case _ => go(p - 1)
    }
    go(x - 1)
  }

  /**
   * Problem 4. A palindromic number reads the same both ways. The largest palindrome made
   *   from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   * Find the largest palindrome made from the product of two 3-digit numbers.
   */
  def getLargestPalindromeForXDigits(x: Int): Long = {
    val ps = getXDigitProducts(x)
    assert(ps.contains(9009))
    val pals = ps.filter{a => isPalindrome(a.toString)}

    pals.foldLeft(0L) {
      (acc, elem) => if(elem > acc) elem
                     else acc
    }
  }

  // TODO: see Sobral's answer on SO
  //http://stackoverflow.com/questions/22593362/outofmemory-exception-when-creating-stream-of-3-digit-products
  def getXDigitProducts(x: Int): Stream[Long] = {
    val MAX = Math.pow(10, x)
    @tailrec
    def go(outer: Int, inner: Int, acc: Stream[Long]): Stream[Long] = (outer, inner) match {
      case (MAX, _) => acc
      case (_, MAX) => println("outer:" + outer); go(outer + 1, 1, acc)
      case (_, _)   => go(outer, inner + 1, Stream[Long](outer * inner) ++ acc)
    }
    go(1, 1, Stream[Long]())
  }

  def isPalindrome(x: String) = x == x.reverse

  def getXDigitProductsTry(x: Int): Stream[Long] = {
    val MAX = Math.pow(10, x)

    def go(outer: Int, inner: Int, product: Stream[Long]): Stream[Long] = {
      if(outer == MAX) product
      else if(inner == MAX) go(outer + 1, 1, product)
      else (outer * inner) #:: go(outer, inner + 1, product)
    }
    go(1, 1, Stream[Long]())
  }

  /**
   * Problem 5.
   * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
   * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
   */

  def smallestNumDivByXNumbers(count: Int, start: Int): Option[Int] = {
    @tailrec
    def go(x: Int): Option[Int] = x match {
      case _ if isDivByX(x, count) => Some(x)
      case Long.MaxValue => None
      case _ => go(x+1)
    }
    go(start)
  }

  def isDivByX(num: Int, count: Int): Boolean = {
    @annotation.tailrec
    def go(x: Int, n: Int): Boolean = n match {
      case 1 => true
      case _ if x % n == 0 => go(x, n - 1)
      case _ => false
    }
    go(num, count)
  }

  /**
   * Problem 6. The sum of the squares of the first ten natural numbers is:
   *    1^2 + 2^2 + ... + 10^2 = 385
   * The sum of the square of the first ten natural numbers is:
   *    (1 + 2 + ... + 10)^2 = 55^2 = 3025
   * Hence the difference is 2640.
   *
   * Find the above for the first 100 numbers.
   */

  def sumOfSquares(end: Int): Double =
    List.range(0,end+1).map{x => Math.pow(x, 2)}.foldLeft(0.0)(_+_)

  def sumSquared(end: Int): Double =
    Math.pow(List.range(0, end+1).foldLeft(0.0)(_+_), 2)

  def squaresDiff(end: Int) =
    sumSquared(end) - sumOfSquares(end)

  /**
   * Problem 7. By listing the first six prime numbers, we can see that
   * the 6th prime is 13.
   *
   * What is the 10,001st prime number?
   */

    def findNthPrime(n: Int): Long = {
    @tailrec
      def go(x: Long, y: Int): Long = isPrime(x) match {
        case false => go(x + 1, y)
        case true if y == (n - 1) => x // if we've already found y-1 primes, then we've now found the y'th prime
        case true => go(x+1, y+1)
      }
      go(2, 0)
    }

  /**
   * Problem 8. Find the greatest product of five consecutive digits in the 1000-digit number.
   * TODO: Copy the long number from Project Euler site
   */

  def stringNumToListWithIndividualtems(x: String): List[Int] = {
    val strings: List[String] = x.split("").toList

    // Converting each maybe string digit into a Some[Long] or None
    def getMaybeNumber(x: String): Option[Int] = {
      if (x.matches("[0-9]+")) Some(x.toInt)   // TODO: verify reg-ex
      else None
    }

    strings.flatMap(getMaybeNumber)
  }

  def getMaxProductForNConsecutive(n: Int, list: List[Int]): Long = {
    @annotation.tailrec
    def go(as: List[Int], acc: Long): Long = as match {
      case Nil => acc
      case x :: xs => {
        val temp = as.take(n).foldLeft(1L)(_*_)
        go(xs, if (temp > acc) temp else acc)
      }
    }
    go(list, 0) // Chose Int.MinValue as second arg at first, but realized max sum will be 9*5 (99999)
  }

  def problem8(n: Int, strNum: String): Long = {
    val xs = stringNumToListWithIndividualtems(strNum)
    getMaxProductForNConsecutive(n, xs)
  }

  /**
   * Problem 9. Find the product of abc of Pythagorean Triple where a + b + c = 1000
   * Remember PT: a < b < c where a^2 + b^2 = c^2
   */
  /*def findPythagoreanTriple: Option[(Int, Int, Int)] = {
    def go(a: Int, b: Int): Option[(Int, Int, Int)] = (a,b) match {
      case (Int.MaxValue, _) => None
      case (_, Int.MaxValue) => go(a+1, a+2)
      case (_,_)
      //if(Math.sqrt(a*b).toString.matches("[1-9]+[0-9]+.[0]+")) => Some(a,b,Math.sqrt(a*b).toInt)
      case _ => go(a, b+1)
    }
    go(2, 3)
  } */

  /*def findPythagoreanTriple: Option[(Int, Int, Int)] = {
    def go(a: Int, b: Int): Option[(Int, Int, Int)] = {
      if(a == Int.MaxValue) None
      else if(b == Int.MaxValue) => go(a+1, a+2)
      else if(isPythTriple(a,b))
    }
    go(2, 3)
  }*/
}